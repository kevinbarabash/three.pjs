<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>THREE.pjs</title>
    <script src="../bower_components/Processing.js/processing.js"></script>
    <script src="../bower_components/three.js/three.js"></script>
    <style>
        
        body {
            margin: 0;
            background-color: gray;
        }
        
        canvas {
            position: absolute;
            left: 0;
            top: 0;
        }
        
    </style>
</head>
<body>

</body>
</html>
<script>

    var camera, renderer, canvas, ctx;
    var geometry, material, mesh;
    var p;

    function Mesh() {
        this.geometry = new THREE.Geometry();
    }

    Mesh.prototype.addVertex = function (x, y, z) {
        var vertex = new THREE.Vector3(x, y, z);
        this.geometry.vertices.push(vertex);
    };

    Mesh.prototype.addFace = function () {
        var color = new THREE.Color(Math.random(), Math.random(), Math.random());
        
        var args = arguments;
        for (var i = 0; i < arguments.length - 2; i++) {
            var face = new THREE.Face3(args[0], args[i + 1], args[i + 2]);
            
            face.color = color;
            this.geometry.faces.push(face);
        }
    };

    var toScreenXY = function( position, camera, scene ) {
        var pos = position.clone();
        var projScreenMat = new THREE.Matrix4();
        projScreenMat.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
        projScreenMat.multiply(scene.matrix);
        pos.applyMatrix4(projScreenMat);
        
        return {
            x: ( pos.x + 1 ),
            y: ( -pos.y + 1)
        };
    };
    
    function init() {
        renderer = new THREE.WebGLRenderer();
        renderer.setSize( 400, 400 );
        renderer.setClearColorHex(0xFFFFFF);
        document.body.appendChild( renderer.domElement );
        
        canvas = document.createElement("canvas");
        canvas.width = 400;
        canvas.height = 400;
        document.body.appendChild(canvas);
        ctx = canvas.getContext("2d");
        ctx.font = "20px sans-serif";
        
        p = new Processing(canvas);
        p.currentScene = new THREE.Scene();
        
        var scene = p.currentScene;
        
//        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
        
        // +x left
        // +y up
        camera = new THREE.OrthographicCamera(-200, 200, 200, -200, 1, 2000);
        camera.position.z = 1000;
        
        var size = 60;
        
        var cube = new Mesh();
        cube.addVertex(-size, -size, -size);
        cube.addVertex( size, -size, -size);
        cube.addVertex( size,  size, -size);
        cube.addVertex(-size,  size, -size);
        cube.addVertex(-size, -size,  size);
        cube.addVertex( size, -size,  size);
        cube.addVertex( size,  size,  size);
        cube.addVertex(-size,  size,  size);
        
        cube.addFace(3, 2, 1, 0);
        cube.addFace(4, 5, 6, 7);
        cube.addFace(0, 4, 7, 3);
        cube.addFace(1, 2, 6, 5);
        cube.addFace(3, 7, 6, 2);
        cube.addFace(0, 1, 5, 4);

        cube.geometry.computeFaceNormals();
        cube.geometry.computeVertexNormals();
        
        material = new THREE.MeshBasicMaterial({ 
            vertexColors: THREE.FaceColors,
            wireframe: false 
        });

        mesh = new THREE.Mesh( cube.geometry, material );
        scene.add( mesh );

        material = new THREE.MeshBasicMaterial( { color: new THREE.Color(0,0,0) } );
        var vertex = new THREE.SphereGeometry(5, 16, 8);

        for (var i = 0; i < 8; i++) {
            var sphere = new THREE.Mesh(vertex, material);
            var corner = cube.geometry.vertices[i];
            sphere.position.set(corner.x, corner.y, corner.z);
            scene.add(sphere);
        }
        
        var drawingMethods = [
            "translate",
            "transform",
            "scale",
            "pushMatrix",
            "popMatrix",
            "resetMatrix",
            "applyMatrix",
            "rotate",
            "rotateZ",
            "shearX",
            "shearY",
            "redraw",
            "toImageData",
            "ambientLight",
            "directionalLight",
            "lightFalloff",
            "lightSpecular",
            "pointLight",
            "noLights",
            "spotLight",
            "beginCamera",
            "endCamera",
            "frustum",
            "box",
            "sphere",
            "ambient",
            "emissive",
            "shininess",
            "specular",
            "fill",
            "stroke",
            "strokeWeight",
            "smooth",
            "noSmooth",
            "point",
            "vertex",
            "endShape",
            "bezierVertex",
            "curveVertex",
            "curve",
            "line",
            "bezier",
            "rect",
            "ellipse",
            "background",
            "image",
            "textWidth",
            "text$line",
            "$ensureContext",
            "$newPMatrix"
        ];
        
        drawingMethods.forEach(function (methodName) {
            delete p[methodName]; 
        });
        
        p.mouseClicked = function () {
            console.log("mouse clicked at (%d, %d)", p.mouseX, p.mouseY);
        }
    }

    function animate() {
        var scene = p.currentScene;

        requestAnimationFrame( animate );

        scene.rotation.x += 0.01;
        scene.rotation.y += 0.02;

        renderer.render( scene, camera );

        var corner = new THREE.Vector3(-60, -60, -60);
        var point = toScreenXY(corner, camera, scene);
        
        point.x *= 200;
        point.y *= 200;
        
        ctx.clearRect(0, 0, 400, 400);
        ctx.fillText("hello", point.x, point.y);
    }
    

    init();
    animate();
    
</script>